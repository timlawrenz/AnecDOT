Get edges corresponding to input path colored_edges = [ edge for edge in graph.edges() if "color" in dict(edge.attr) ] colored_edges.sort(key=lambda edge: edge.attr["label"][2:])  edge_pairs = [ edge[0:2] for edge in self.dfa._get_input_path(input_string)[0] ] self.assertEqual(edge_pairs, colored_edges)  def test_show_diagram_initial_final_same(self) -> None: """ Should construct the diagram for a DFA whose initial state is also a final state. """ This DFA accepts all words which do not contain two consecutive occurrences of 1 dfa = self.no_consecutive_11_dfa  graph = dfa.show_diagram() node_names = {node.get_name() for node in graph.nodes()} self.assertTrue(set(dfa.states).issubset(node_names)) self.assertEqual(len(dfa.states) + 1, len(node_names))  for state in dfa.states: node = graph.get_node(state) expected_shape = "doublecircle" if state in dfa.final_states else "circle" self.assertEqual(node.attr["shape"], expected_shape)  expected_transitions = { ("p0", "0", "p0"), ("p0", "1", "p1"), ("p1", "0", "p0"), ("p1", "1", "p2"), ("p2", "0,1", "p2"), } seen_transitions = { (edge[0], edge.attr["label"], edge[1]) for edge in graph.edges() } self.assertTrue(expected_transitions.issubset(seen_transitions)) self.assertEqual(len(expected_transitions) + 1, len(seen_transitions))  source, symbol, dest = list(seen_transitions - expected_transitions)[0] self.assertEqual(symbol, "") self.assertEqual(dest, dfa.initial_state) self.assertTrue(source not in dfa.states)  def test_show_diagram_write_file(self) -> None: """ Should construct the diagram for a DFA and write it to the specified file. """ diagram_path = os.path.join(self.temp_dir_path, "test_dfa.png") try: os.remove(diagram_path) except OSError: pass self.assertFalse(os.path.exists(diagram_path)) self.dfa.show_diagram(path=diagram_path) self.assertTrue(os.path.exists(diagram_path)) os.remove(diagram_path)  def test_repr_mimebundle_same(self) -> None: """ Check that the mimebundle is the same. """  random.seed(42) first_repr = self.dfa._repr_mimebundle_() random.seed(42) second_repr = self.dfa.show_diagram()._repr_mimebundle_() self.assertEqual(first_repr, second_repr)  def test_show_diagram_orientations(self) -> None: graph = self.dfa.show_diagram() self.assertEqual(graph.graph_attr["rankdir"], "LR") graph = self.dfa.show_diagram(horizontal=False) self.assertEqual(graph.graph_attr["rankdir"], "TB") graph = self.dfa.show_diagram(reverse_orientation=True) self.assertEqual(graph.graph_attr["rankdir"], "RL") graph = self.dfa.show_diagram(horizontal=False, reverse_orientation=True) self.assertEqual(graph.graph_attr["rankdir"], "BT")  def test_show_diagram_fig_size(self) -> None: """ Testing figure size. Just need to make sure it matches the input (the library handles the rendering). """ graph = self.dfa.show_diagram(fig_size=(1.1, 2)) self.assertEqual(graph.graph_attr["size"], "1.1, 2")  graph = self.dfa.show_diagram(fig_size=(3.3,)) self.assertEqual(graph.graph_attr["size"], "3.3")  @params(True, False) def test_minimal_finite_language(self, as_partial: bool) -> None: """Should compute the minimal DFA accepting the given finite language"""  Same language described in the book this algorithm comes from language = { "aa", "aaa", "aaba", "aabbb", "abaa", "ababb", "abbab", "baa", "babb", "bbaa", "bbabb", "bbbab", }  equiv_dfa = DFA( states=set(range(10)), input_symbols={"a", "b"}, transitions={ 0: {"a": 0, "b": 0}, 1: {"a": 2, "b": 3}, 2: {"a": 4, "b": 5}, 3: {"a": 7, "b": 5}, 4: {"a": 9, "b": 7}, 5: {"a": 7, "b": 6}, 6: {"a": 8, "b": 0}, 7: {"a": 9, "b": 8}, 8: {"a": 0, "b": 9}, 9: {"a": 0, "b": 0}, }, initial_state=1, final_states={4, 9}, )  if as_partial: equiv_dfa = equiv_dfa.to_partial()  minimal_dfa = DFA.from_finite_language( {"a", "b"}, language, as_partial=as_partial )  self.assertEqual(len(minimal_dfa.states), len(equiv_dfa.states)) self.assertEqual(minimal_dfa, equiv_dfa)  @params(True, False) def test_minimal_finite_language_large(self, as_partial: bool) -> None: """Should compute the minimal DFA accepting the given finite language on large test case""" m = 50 n = 50 language = {("a" * i + "b" * j) for i, j in product(range(n), range(m))}  equiv_dfa = DFA.from_finite_language( {"a", "b"}, language, as_partial=as_partial ) minimal_dfa = equiv_dfa.minify()  self.assertEqual(equiv_dfa, minimal_dfa) self.assertEqual(len(equiv_dfa.states), len(minimal_dfa.states))  dfa_language = {word for word in equiv_dfa} self.assertEqual(dfa_language, language)  def test_dfa_repr(self) -> None: """Should display proper string representation of DFA"""