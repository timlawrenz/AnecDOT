Source: caleb531/automata test suite
Type: DFA
Description: This DFA accepts all words which contain at least four occurrences of 1 dfa1 = self.at_least_four_ones This DFA accepts all words which do not contain two consecutive occurrences of 1 dfa2 = self.no_consecutive_11_dfa new_dfa = dfa1.union(dfa2, retain_names=True, minify=False) self.assertEqual( new_dfa.states, { ("q0", "p0"), ("q1", "p0"), ("q1", "p1"), ("q2", "p0"), ("q2", "p1"), ("q2", "p2"), ("q3", "p0"), ("q3", "p1"), ("q3", "p2"), ("q4", "p0"), ("q4", "p1"), ("q4", "p2"), }, ) self.assertEqual(new_dfa.input_symbols, {"0", "1"}) self.assertEqual( new_dfa.transitions, { ("q0", "p0"): {"0": ("q0", "p0"), "1": ("q1", "p1")}, ("q1", "p0"): {"0": ("q1", "p0"), "1": ("q2", "p1")}, ("q1", "p1"): {"0": ("q1", "p0"), "1": ("q2", "p2")}, ("q2", "p0"): {"0": ("q2", "p0"), "1": ("q3", "p1")}, ("q2", "p1"): {"0": ("q2", "p0"), "1": ("q3", "p2")}, ("q2", "p2"): {"0": ("q2", "p2"), "1": ("q3", "p2")}, ("q3", "p0"): {"0": ("q3", "p0"), "1": ("q4", "p1")}, ("q3", "p1"): {"0": ("q3", "p0"), "1": ("q4", "p2")}, ("q3", "p2"): {"0": ("q3", "p2"), "1": ("q4", "p2")}, ("q4", "p0"): {"0": ("q4", "p0"), "1": ("q4", "p1")}, ("q4", "p1"): {"0": ("q4", "p0"), "1": ("q4", "p2")}, ("q4", "p2"): {"0": ("q4", "p2"), "1": ("q4", "p2")}, }, ) self.assertEqual(new_dfa.initial_state, ("q0", "p0")) self.assertEqual( new_dfa.final_states, { ("q0", "p0"), ("q1", "p0"), ("q1", "p1"), ("q2", "p0"), ("q2", "p1"), ("q3", "p0"), ("q3", "p1"), ("q4", "p0"), ("q4", "p1"), ("q4", "p2"), }, )  Test retain names logic without minify self.assertEqual(dfa1.union(dfa2, retain_names=False, minify=False), new_dfa)  def test_intersection(self) -> None: """Should compute the intersection between two DFAs""" This DFA accepts all words which contain at least four occurrences of 1 dfa1 = self.at_least_four_ones This DFA accepts all words which do not contain two consecutive occurrences of 1 dfa2 = self.no_consecutive_11_dfa new_dfa = dfa1.intersection(dfa2, retain_names=True, minify=False) self.assertEqual( new_dfa.states, { ("q0", "p0"), ("q1", "p0"), ("q1", "p1"), ("q2", "p0"), ("q2", "p1"), ("q2", "p2"), ("q3", "p0"), ("q3", "p1"), ("q3", "p2"), ("q4", "p0"), ("q4", "p1"), ("q4", "p2"), }, ) self.assertEqual(new_dfa.input_symbols, {"0", "1"}) self.assertEqual( new_dfa.transitions, { ("q0", "p0"): {"0": ("q0", "p0"), "1": ("q1", "p1")}, ("q1", "p0"): {"0": ("q1", "p0"), "1": ("q2", "p1")}, ("q1", "p1"): {"0": ("q1", "p0"), "1": ("q2", "p2")}, ("q2", "p0"): {"0": ("q2", "p0"), "1": ("q3", "p1")}, ("q2", "p1"): {"0": ("q2", "p0"), "1": ("q3", "p2")}, ("q2", "p2"): {"0": ("q2", "p2"), "1": ("q3", "p2")}, ("q3", "p0"): {"0": ("q3", "p0"), "1": ("q4", "p1")}, ("q3", "p1"): {"0": ("q3", "p0"), "1": ("q4", "p2")}, ("q3", "p2"): {"0": ("q3", "p2"), "1": ("q4", "p2")}, ("q4", "p0"): {"0": ("q4", "p0"), "1": ("q4", "p1")}, ("q4", "p1"): {"0": ("q4", "p0"), "1": ("q4", "p2")}, ("q4", "p2"): {"0": ("q4", "p2"), "1": ("q4", "p2")}, }, ) self.assertEqual(new_dfa.initial_state, ("q0", "p0")) self.assertEqual( new_dfa.final_states, { ("q4", "p0"), ("q4", "p1"), }, )  Test retain names logic without minify self.assertEqual( dfa1.intersection(dfa2, retain_names=False, minify=False), new_dfa )  def test_difference(self) -> None: """Should compute the difference between two DFAs""" This DFA accepts all words which contain at least four occurrences of 1 dfa1 = self.at_least_four_ones This DFA accepts all words which do not contain two consecutive occurrences of 1 dfa2 = self.no_consecutive_11_dfa new_dfa = dfa1.difference(dfa2, retain_names=True, minify=False) self.assertEqual( new_dfa.states, { ("q0", "p0"), ("q1", "p0"), ("q1", "p1"), ("q2", "p0"), ("q2", "p1"), ("q2", "p2"), ("q3", "p0"), ("q3", "p1"), ("q3", "p2"), ("q4", "p0"), ("q4", "p1"), ("q4", "p2"), }, ) self.assertEqual(new_dfa.input_symbols, {"0", "1"}) self.assertEqual( new_dfa.transitions, { ("q0", "p0"): {"0": ("q0", "p0"), "1": ("q1", "p1")}, ("q1", "p0"): {"0": ("q1", "p0"), "1": ("q2", "p1")}, ("q1", "p1"): {"0": ("q1", "p0"), "1": ("q2", "p2")}, ("q2", "p0"): {"0": ("q2", "p0"), "1": ("q3", "p1")}, ("q2", "p1"): {"0": ("q2", "p0"), "1": ("q3", "p2")}, ("q2", "p2"): {"0": ("q2", "p2"), "1": ("q3", "p2")}, ("q3", "p0"): {"0": ("q3", "p0"), "1": ("q4", "p1")}, ("q3", "p1"): {"0": ("q3", "p0"), "1": ("q4", "p2")}, ("q3", "p2"): {"0": ("q3", "p2"), "1": ("q4", "p2")}, ("q4", "p0"): {"0": ("q4", "p0"), "1": ("q4", "p1")}, ("q4", "p1"): {"0": ("q4", "p0"), "1": ("q4", "p2")}, ("q4", "p2"): {"0": ("q4", "p2"), "1": ("q4", "p2")}, }, ) self.assertEqual(new_dfa.initial_state, ("q0", "p0")) self.assertEqual(new_dfa.final_states, {("q4", "p2")})  Test retain names logic without minify self.assertEqual( dfa1.difference(dfa2, retain_names=False, minify=False), new_dfa )  def test_symmetric_difference(self) -> None: """Should compute the symmetric difference between two DFAs""" This DFA accepts all words which contain at least four occurrences of 1 dfa1 = self.at_least_four_ones This DFA accepts all words which do not contain two consecutive occurrences of 1 dfa2 = self.no_consecutive_11_dfa new_dfa = dfa1.symmetric_difference(dfa2, retain_names=True, minify=False) self.assertEqual( new_dfa.states, { ("q0", "p0"), ("q1", "p0"), ("q1", "p1"), ("q2", "p0"), ("q2", "p1"), ("q2", "p2"), ("q3", "p0"), ("q3", "p1"), ("q3", "p2"), ("q4", "p0"), ("q4", "p1"), ("q4", "p2"), }, ) self.assertEqual(new_dfa.input_symbols, {"0", "1"}) self.assertEqual( new_dfa.transitions, { ("q0", "p0"): {"0": ("q0", "p0"), "1": ("q1", "p1")}, ("q1", "p0"): {"0": ("q1", "p0"), "1": ("q2", "p1")}, ("q1", "p1"): {"0": ("q1", "p0"), "1": ("q2", "p2")}, ("q2", "p0"): {"0": ("q2", "p0"), "1": ("q3", "p1")}, ("q2", "p1"): {"0": ("q2", "p0"), "1": ("q3", "p2")}, ("q2", "p2"): {"0": ("q2", "p2"), "1": ("q3", "p2")}, ("q3", "p0"): {"0": ("q3", "p0"), "1": ("q4", "p1")}, ("q3", "p1"): {"0": ("q3", "p0"), "1": ("q4", "p2")}, ("q3", "p2"): {"0": ("q3", "p2"), "1": ("q4", "p2")}, ("q4", "p0"): {"0": ("q4", "p0"), "1": ("q4", "p1")}, ("q4", "p1"): {"0": ("q4", "p0"), "1": ("q4", "p2")}, ("q4", "p2"): {"0": ("q4", "p2"), "1": ("q4", "p2")}, }, ) self.assertEqual(new_dfa.initial_state, ("q0", "p0")) self.assertEqual( new_dfa.final_states, { ("q0", "p0"), ("q1", "p0"), ("q1", "p1"), ("q2", "p0"), ("q2", "p1"), ("q3", "p0"), ("q3", "p1"), ("q4", "p2"), }, )  Test retain names logic without minify self.assertEqual( dfa1.symmetric_difference(dfa2, retain_names=False, minify=False), new_dfa )  def test_issubset(self) -> None: """Should test if one DFA is a subset of another"""  Test both proper subset and subset with each set as left hand side self.assertTrue(self.zero_or_one_1_dfa < self.no_consecutive_11_dfa) self.assertTrue(self.zero_or_one_1_dfa <= self.no_consecutive_11_dfa) self.assertFalse(self.no_consecutive_11_dfa < self.zero_or_one_1_dfa) self.assertFalse(self.no_consecutive_11_dfa <= self.zero_or_one_1_dfa)  single_string_dfa = DFA.from_finite_language( {"0", "1"}, {"101"}, as_partial=True )  Test interop with partial DFA self.assertFalse(self.partial_dfa < self.zero_or_one_1_dfa) self.assertFalse(self.partial_dfa <= self.zero_or_one_1_dfa)  self.assertTrue(single_string_dfa < self.no_consecutive_11_dfa) self.assertTrue(single_string_dfa <= self.no_consecutive_11_dfa)  def test_issuperset(self) -> None: """Should test if one DFA is a superset of another"""  Test both proper subset and subset with each set as left hand side self.assertFalse(self.zero_or_one_1_dfa > self.no_consecutive_11_dfa) self.assertFalse(self.zero_or_one_1_dfa >= self.no_consecutive_11_dfa)  self.assertTrue(self.no_consecutive_11_dfa > self.zero_or_one_1_dfa) self.assertTrue(self.no_consecutive_11_dfa >= self.zero_or_one_1_dfa)  single_string_dfa = DFA.from_finite_language( {"0", "1"}, {"101"}, as_partial=True )  Test interop with partial DFA self.assertFalse(self.zero_or_one_1_dfa > self.partial_dfa) self.assertFalse(self.zero_or_one_1_dfa >= self.partial_dfa)  self.assertTrue(self.no_consecutive_11_dfa > single_string_dfa) self.assertTrue(self.no_consecutive_11_dfa >= single_string_dfa)  def test_symbol_mismatch(self) -> None: """Should test if symbol mismatch is raised""" This DFA accepts all words which contain either zero or one occurrence of b
