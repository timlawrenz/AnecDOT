This DFA accepts all binary strings which have length less than or equal to 5 dfa = DFA.of_length({"0", "1"}, min_length=0, max_length=5) self.assertTrue(dfa.isfinite())  def test_isfinite_empty(self) -> None: """Should test if an empty DFA is finite"""  self.assertTrue(self.no_reachable_final_dfa.isfinite())  def test_isfinite_universe(self) -> None: This DFA accepts all binary strings and therefore is infinite. dfa = DFA.universal_language({"0", "1"}) self.assertFalse(dfa.isfinite())  @params( *get_permutation_tuples( DFA.from_substring(set("01"), "1111"), partial_dfa, no_consecutive_11_dfa, at_least_four_ones, zero_or_one_1_dfa, no_reachable_final_dfa, ) ) def test_set_laws(self, dfa1: DFA, dfa2: DFA) -> None: """Tests many set laws that are true for all sets""" This DFA accepts all words which contain at least four occurrences of 1 input_symbols = {"0", "1"}  dfa1 = dfa1.to_complete() dfa2 = dfa2.to_partial() dfa1 = DFA.from_substring(input_symbols, "1111") This DFA accepts all words which do not contain two consecutive occurrences of 1 dfa2 = DFA.from_substring(input_symbols, "11").complement(minify=False)  DFAs have to be not equal for test to work self.assertNotEqual(dfa1, dfa2)  This DFA accepts all binary strings universal = DFA.universal_language(input_symbols) This DFA represents the empty language empty = DFA.empty_language(input_symbols) De Morgan's laws self.assertEqual(~(dfa1 | dfa2), ~dfa1 & ~dfa2) self.assertEqual(~(dfa1 & dfa2), ~dfa1 | ~dfa2) Complement laws self.assertEqual(dfa1 | ~dfa1, universal) self.assertEqual(dfa1 & ~dfa1, empty) self.assertEqual(~universal, empty) self.assertEqual(~empty, universal) Involution self.assertEqual(dfa1, ~(~dfa1)) Relationships between relative and absolute complements self.assertEqual(dfa1 - dfa2, dfa1 & ~dfa2) self.assertEqual(~(dfa1 - dfa2), ~dfa1 | dfa2) self.assertEqual(~(dfa1 - dfa2), ~dfa1 | (dfa2 & dfa1)) Relationship with set difference self.assertEqual(~dfa1 - ~dfa2, dfa2 - dfa1) Symmetric difference self.assertEqual( dfa1 ^ dfa2, (dfa1 - dfa2) | (dfa2 - dfa1), ) self.assertEqual( dfa1 ^ dfa2, (dfa1 | dfa2) - (dfa1 & dfa2), ) Commutativity self.assertEqual(dfa1 | dfa2, dfa2 | dfa1) self.assertEqual(dfa1 & dfa2, dfa2 & dfa1) self.assertEqual(dfa1 ^ dfa2, dfa2 ^ dfa1)  def test_minify_dfa(self) -> None: """Should minify a given DFA.""" This DFA accepts all words which are at least two characters long. The states q1/q2 and q3/q4/q5/q6 are redundant. The state q7 is not reachable.