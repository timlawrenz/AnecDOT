type: ignore states={"q0", "q1"}, input_symbols={"0", "1"}, initial_state="q0", final_states={"q1"}, )  def test_copy_dfa(self) -> None: """Should create exact copy of DFA if copy() method is called.""" new_dfa = self.dfa.copy() self.assertIsNot(new_dfa, self.dfa)  def test_dfa_immutable_attr_set(self) -> None: """Should disallow reassigning DFA attributes""" with self.assertRaises(AttributeError): self.dfa.states = {}  # type: ignore  def test_dfa_immutable_attr_del(self) -> None: """Should disallow deleting DFA attributes""" with self.assertRaises(AttributeError): del self.dfa.states  def test_dfa_immutable_dict(self) -> None: """Should create a DFA whose contents are fully immutable/hashable""" self.assertIsInstance(hash(frozendict(self.dfa.input_parameters)), int)  @patch("automata.fa.dfa.DFA.validate") def test_init_validation(self, validate: MagicMock) -> None: """Should validate DFA when initialized.""" self.dfa.copy() validate.assert_called_once_with()  def test_dfa_equal(self) -> None: """Should correctly determine if two DFAs are equal.""" new_dfa = self.dfa.copy() self.assertTrue(self.dfa == new_dfa, "DFAs are not equal")  def test_dfa_not_equal(self) -> None: """Should correctly determine if two DFAs are not equal."""